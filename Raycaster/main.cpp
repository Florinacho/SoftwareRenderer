// https://github.com/3DSage/OpenGL-Raycaster_v2/blob/main/3DSage_Raycaster_v2.c

#include <stdio.h>
#include <math.h>

#if defined (_WIN32)
#include "Window.h"
#elif defined (__linux__)
#include <linux/input.h>
#include "Input.h"
#include "FrameBuffer.h"
#endif 

#include "Timer.h"

const uvec2 WindowSize(480, 320);
const uvec2 TextureSize(32, 32);
const float DEGTORAD = M_PI / 180.0f;

float FixAng(float a) {
	if(a >= 360.0f) {
		a -= 360.0f;
	}
	if(a < 0.0f) {
		a += 360.0f;
	}
	return a;
}

float px, py, pdx, pdy, pa;

int All_Textures[]=               //all 32x32 textures
{
	//Checkerboard
	0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1,
	0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1,
	0,0,0,0,0,1,1,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1,
	0,0,1,1,1,1,1,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1,
	0,0,1,1,1,1,1,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1,
	0,0,0,0,0,1,1,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1,
	0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1,
	0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1,

	1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 
	1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 
	1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 
	1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 
	1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 
	1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 
	1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 
	1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0,

	0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1,
	0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1,
	0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1,
	0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1,
	0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1,
	0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1,
	0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1,
	0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1,

	1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 
	1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 
	1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 
	1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 
	1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 
	1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 
	1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 
	1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 

	//Brick
	0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
	1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1,
	0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,

	0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
	0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,
	0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,
	0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,
	0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,
	0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,
	0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,
	0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,

	0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
	1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1,
	0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,

	0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
	0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,
	0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,
	0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,
	0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,
	0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,
	0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,
	0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,

	// Window
	1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1,  
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1,  
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1,  
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1,
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1,    

	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1,  
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1,  
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1,  
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1,  
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1,
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 
	1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 

	1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,  
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1,  
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1,  
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1,  
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1,
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1,   

	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1,  
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1,  
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1,  
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1,  
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1,
	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1,
	1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,
	
	// Door
	0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,  
	0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,  
	0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,    
	0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,    
	0,0,0,1,1,1,1,1, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 1,1,1,1,1,0,0,0,  
	0,0,0,1,0,0,0,1, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 1,0,0,0,1,0,0,0,  
	0,0,0,1,0,0,0,1, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 1,0,0,0,1,0,0,0,   
	0,0,0,1,0,0,0,1, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 1,0,0,0,1,0,0,0,     

	0,0,0,1,0,0,0,1, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 1,0,0,0,1,0,0,0,  
	0,0,0,1,0,0,0,1, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 1,0,0,0,1,0,0,0,    
	0,0,0,1,0,0,0,1, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 1,0,0,0,1,0,0,0,    
	0,0,0,1,0,0,0,1, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 1,0,0,0,1,0,0,0,   
	0,0,0,1,0,0,0,1, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 1,0,0,0,1,0,0,0,  
	0,0,0,1,0,0,0,1, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 1,0,0,0,1,0,0,0,  
	0,0,0,1,0,0,0,1, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 1,0,0,0,1,0,0,0,  
	0,0,0,1,1,1,1,1, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 1,1,1,1,1,0,0,0,  

	0,0,0,0,0,0,0,0, 0,0,0,0,0,1,0,1, 1,0,1,0,0,0,0,0, 0,0,0,0,0,0,0,0,  
	0,0,0,0,0,0,0,0, 0,0,1,1,1,1,0,1, 1,0,1,1,1,1,0,0, 0,0,0,0,0,0,0,0,   
	0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,    
	0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,    
	0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,  
	0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,  
	0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,   
	0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 

	0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,  
	0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,     
	0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,   
	0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,   
	0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,   
	0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,  
	0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,   
	0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,         
};

// MAP
#define mapX  8      //map width
#define mapY  8      //map height
#define mapS 64      //map cube size

// walls
int mapW[] = {
	1,1,1,1,1,3,1,1,
	1,0,0,1,0,0,0,1,
	1,0,0,4,0,2,0,1,
	1,1,4,1,0,0,0,1,
	2,0,0,0,0,0,0,1,
	2,0,0,0,0,1,0,1,
	2,0,0,0,0,0,0,1,
	1,1,3,1,3,1,3,1,	
};

// floors
int mapF[] = {
	0,0,0,0,0,0,0,0,
	0,0,0,0,1,1,0,0,
	0,0,0,0,2,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,2,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,1,1,1,1,0,0,0,
	0,0,0,0,0,0,0,0,	
};

// ceiling
int mapC[] = {
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,1,0,
	0,1,3,1,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,	
};

void DrawRays2D(Image* output, Image* textures, const unsigned int textureCount) {
	int mx, my, mp, dof, side; 
	float vx, vy, rx, ry, ra, xo, yo, disV, disH; 
	float fovY = 70;
	const float deltaRayRadAngle = ((float)WindowSize.x / (float)fovY) * DEGTORAD;
 
	ra = FixAng(pa + fovY / 2.0f);
 
	for(int r = 0; r < WindowSize.x; ++r) {
		int vmt = 0; // vertical map texture number 
		int hmt = 0; // horizontal map texture number 
		
		// Vertical
		dof = 0; 
		side = 0; 
		disV = 100000;

		const float playerAngleRad = ra * DEGTORAD;
		const float cosPlayerAngle = cosf(playerAngleRad);
		const float sinPlayerAngle = sinf(playerAngleRad);
		
		float Tan = tan(playerAngleRad);
	
		if(cosPlayerAngle > 0.001) {
			// looking left
			rx = (((int)px >> 6) << 6) + 64;
			ry = (px - rx) * Tan + py;
			xo = 64;
			yo = -xo * Tan;
		} else if(cosPlayerAngle < -0.001) {
			// looking right
			rx = (((int)px >> 6) << 6) - 0.0001;
			ry = (px - rx) * Tan + py;
			xo = -64;
			yo = -xo * Tan;
		} else {
			// looking up or down. no hit  
			rx = px;
			ry = py;
			dof = 8;
		}

		while(dof < 8) { 
			mx = (int)(rx) >> 6;
			my = (int)(ry) >> 6;
			mp = my * mapX + mx;
			
			if(mp > 0 && mp < mapX * mapY && mapW[mp] > 0) {
				// hit
				vmt = mapW[mp] - 1;
				dof = 8;
				disV = cosPlayerAngle * (rx - px) - sinPlayerAngle * (ry - py);
			} else {
				// check next horizontal
				rx += xo;
				ry += yo;
				dof += 1;
			}
		} 
		
		vx = rx;
		vy = ry;

		// Horizontal
		dof = 0; 
		disH = 100000;
		Tan = 1.0 / Tan; 

		if(sinPlayerAngle > 0.001) {
			// looking up 
			ry = (((int)py >> 6) << 6) - 0.0001;
			rx = (py - ry) * Tan + px;
			yo = -64;
			xo = -yo * Tan;
		} else if(sinPlayerAngle < -0.001){
			// looking down
			ry = (((int)py >> 6) << 6) + 64;
			rx = (py - ry) * Tan + px;
			yo = 64;
			xo = -yo * Tan;
		} else {
			// looking straight left or right
			rx = px;
			ry = py;
			dof = 8;
		}
 
		while(dof < 8) { 
			mx = (int)(rx) >> 6;
			my = (int)(ry) >> 6;
			mp = my * mapX + mx;                          

			if(mp > 0 && mp < mapX * mapY && mapW[mp] > 0) {
				// hit
				hmt = mapW[mp] - 1;
				dof = 8;
				disH = cosPlayerAngle * (rx - px) - sinPlayerAngle * (ry - py);
			} else {
				// check next horizontal
				rx += xo;
				ry += yo;
				dof += 1;
			}
		} 
  
		float shade = 1.0f;

		if(disV < disH){
			// horizontal hit first
			hmt = vmt; 
			shade = 0.5; 
			rx = vx; 
			ry = vy; 
			disH = disV; 
		}

		int ca = FixAng(pa - ra);
		disH = disH * cos(ca * DEGTORAD); // fix fisheye
		int lineH = (mapS * WindowSize.y) / (disH);
		const float ty_step = (float)TextureSize.y / (float)lineH;
		float ty_off = 0;
		
		if(lineH > WindowSize.y) {
			// line height and limit
			ty_off = (lineH - WindowSize.y) >> 1;
			lineH = WindowSize.y;
		}

		int lineOff = (WindowSize.y >> 1) - (lineH >> 1); // line offset

		// draw walls
		int y;
		float ty = ty_off * ty_step + hmt * (float)TextureSize.y;
		float tx;
		
		// Fix texture orientation
		if(shade == 1){
			tx = (int)(rx / 2.0) % 32;
			if(ra > 180){
				tx = 31 - tx;
			}
		} else {
			tx = (int)(ry / 2.0) % 32;
			if(ra > 90 && ra < 270) {
				tx = 31 - tx;
			}
		}
		
		
		for(y = 0; y < lineH; ++y) {
			float c = All_Textures[(int)(ty) * 32 + (int)(tx)] * shade;
			output->setRawPixel(r, y + lineOff, Vector4ub(c * 255.0f, c * 255.0f, c * 255.0f, 255));
			ty += ty_step;
		}

		for(y = lineOff + lineH; y < WindowSize.y; ++y) {
			float dy = y - (WindowSize.y >> 1);
			float raFix = cos(FixAng(pa - ra) * DEGTORAD);
			tx = px / 2 + cosPlayerAngle * 158 * 32 / dy / raFix;
			ty = py / 2 - sinPlayerAngle * 158 * 32 / dy / raFix;

			// draw floors
			int mp = mapF[(int)(ty / 32.0) * mapX + (int)(tx / 32.0)] * 32 * 32;
			float c = All_Textures[((int)(ty) & 31) * 32 + ((int)(tx) & 31) + mp] * 0.7;
  
			output->setRawPixel(r, y, Vector4ub(c / 1.3 * 255.0f, c / 1.3 * 255.0f, c * 255.0f, 255));

			// draw ceiling
			mp = mapC[(int)(ty / 32.0) * mapX + (int)(tx / 32.0)] * 32 * 32;
			c = All_Textures[((int)(ty) & 31) * 32 + ((int)(tx) & 31) + mp] * 0.7;

			output->setRawPixel(r, WindowSize.y - y, Vector4ub(c / 2.0 * 255.0f, c / 1.2 * 255.0f, c / 2.0 * 255.0f, 255));
		}

		// Advance next ray angle
		ra = FixAng(ra - deltaRayRadAngle);
		
	}
}


int main(int argc, char* argv[]) { 
	/*************************************************************************/
	/* Output                                                                */
	/*************************************************************************/
#if defined (_WIN32)
	Win32Window output;	
	if (output.initialize(WindowSize, Image::EPF_R8G8B8, "Raycaster") == false) {
		printf("Failed to initialize the win32 window.\n");
		return 1;
	}
#elif defined (__linux__)
	FrameBuffer output;
	if (output.initialize(NULL, WindowSize, Image::EPF_R8G8B8A8) != 0) {
		printf("Failed to initialize the frame buffer.\n");
		return 1;
	}
	output.input.addAllInputs();
#else
	#error Unsupported platform!
#endif

	Image colorBuffer;
	colorBuffer.create(output.getSize(), output.getPixelFormat());
	colorBuffer.wrapping.x = Image::EWT_DISCARD;
	colorBuffer.wrapping.y = Image::EWT_DISCARD;

	/*************************************************************************/
	/* Load resources.                                                        */
	/*************************************************************************/
	Image textures[2];
	if (textures[0].load("brick.tga") == false) {
		printf("Error! Failed to load brick.tga\n");
		return 1;
	}
	textures[0].wrapping = Image::EWT_REPEAT;

	if (textures[1].load("tex_door.tga") == false) {
		printf("Error! Failed to load tex_door.tga\n");
		return 1;
	}
	textures[1].wrapping = Image::EWT_REPEAT;

	/*************************************************************************/
	/* Misc.                                                                 */
	/*************************************************************************/
	float deltaTime = 1.0f;
	unsigned long long lastTime = Timer::GetMilliSeconds();
	unsigned long long currentTime = lastTime;

	unsigned long long lastFPSTime = lastTime;
	unsigned int frameCount = 0;
	unsigned int totalFPS = 0;
	unsigned int totalSeconds = 0;
	
	Event event;
	bool running = true;
	bool keys[4] = {false, false, false, false};
	px = 150; 
	py = 400; 
	pa = 90;
	pdx =  cos(pa * DEGTORAD);
	pdy = -sin(pa * DEGTORAD); // init player
	
	while (running) {
		/*********************************************************************/
		/* Calculate FPS.                                                    */
		/*********************************************************************/
		currentTime = Timer::GetMilliSeconds();
		deltaTime = (currentTime - lastTime) * 0.001f;
		lastTime = currentTime;

		if (currentTime - lastFPSTime >= 1000) {
			totalFPS += frameCount;
			totalSeconds += 1;
			frameCount = 0;
			lastFPSTime += 1000;
		}

		/*********************************************************************/
		/* Check keyboard events.                                            */
		/*********************************************************************/
		while (output.getEvent(&event)) {
			if (event.type != Event::KEYBOARD) {
				continue; // Skip non-keyboard event types
			}
			
			switch (event.key) {
			case KEY_UP :
				keys[0] = event.state;
				break;
			case KEY_LEFT :
				keys[1] = event.state;
				break;
			case KEY_DOWN :
				keys[2] = event.state;
				break;
			case KEY_RIGHT :
				keys[3] = event.state;
				break;
			case KEY_ESCAPE :
				if (event.state == 0) {
					running = false;
				}
				break;
			}
		}

		/*********************************************************************/
		/* Render scene.                                                     */
		/*********************************************************************/
		if(keys[1]){
			pa += deltaTime * 100.0f;
			pa = FixAng(pa);
			pdx = cos(pa * DEGTORAD);
			pdy = -sin(pa * DEGTORAD);
		}
		if(keys[3]) {
			pa -= deltaTime * 100.0f;
			pa = FixAng(pa);
			pdx = cos(pa * DEGTORAD);
			pdy = -sin(pa * DEGTORAD);
		} 

		int xo=0;
		// x offset to check map
		if(pdx < 0) {
			xo = -20;
		} else{
			xo = 20;
		}
		int yo = 0;
		// y offset to check map
		if(pdy < 0) {
			yo = -20;
		} else{
			yo = 20;
		}
		int ipx = px / 64.0;
		int ipx_add_xo = (px + xo) / 64.0;
		int ipx_sub_xo = (px - xo) / 64.0;             // x position and offset
		int ipy = py / 64.0;
		int ipy_add_yo = (py + yo) / 64.0;
		int ipy_sub_yo = (py - yo) / 64.0;             // y position and offset
		
		if(keys[0]) {  
			//move forward
			if(mapW[ipy * mapX + ipx_add_xo] == 0) {
				px += pdx * deltaTime * 100.0f;
			}
			if(mapW[ipy_add_yo * mapX + ipx] == 0){
				py += pdy * deltaTime * 100.0f;
			}
		}
		if(keys[2]) { 
			//move backward
			if(mapW[ipy * mapX + ipx_sub_xo] == 0) {
				px -= pdx * deltaTime * 100.0f;
			}
			if(mapW[ipy_sub_yo * mapX + ipx] == 0){
				py -= pdy * deltaTime * 100.0f;
			}
		} 
		
		DrawRays2D(&colorBuffer, textures, 2);
		
		/*********************************************************************/
		/* Send color buffer to the screen.                                  */
		/*********************************************************************/
		output.blit(&colorBuffer);
	
		++frameCount;
	}

	/*************************************************************************/
	/* Clear screen and display FPS.                                         */
	/*************************************************************************/
	// output.clearColor();
	printf("\nAverage FPS: %.2f\n", (float)totalFPS / (float)totalSeconds);
	
	return 0;
}